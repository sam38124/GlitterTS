import Point from"./point";import Rect from"./rect";import arrayMax from"./array-max";import arrayMin from"./array-min";export function getColumnSpan(itemWidth,columnWidth,columns,threshold){let columnSpan=itemWidth/columnWidth;if(Math.abs(Math.round(columnSpan)-columnSpan)<threshold){columnSpan=Math.round(columnSpan)}return Math.min(Math.ceil(columnSpan),columns)}export function getAvailablePositions(positions,columnSpan,columns){if(columnSpan===1){return positions}const available=[];for(let i=0;i<=columns-columnSpan;i++){available.push(arrayMax(positions.slice(i,i+columnSpan)))}return available}export function getShortColumn(positions,buffer){const minPosition=arrayMin(positions);for(let i=0,len=positions.length;i<len;i++){if(positions[i]>=minPosition-buffer&&positions[i]<=minPosition+buffer){return i}}return 0}export function getItemPosition({itemSize:itemSize,positions:positions,gridSize:gridSize,total:total,threshold:threshold,buffer:buffer}){const span=getColumnSpan(itemSize.width,gridSize,total,threshold);const setY=getAvailablePositions(positions,span,total);const shortColumnIndex=getShortColumn(setY,buffer);const point=new Point(gridSize*shortColumnIndex,setY[shortColumnIndex]);const setHeight=setY[shortColumnIndex]+itemSize.height;for(let i=0;i<span;i++){positions[shortColumnIndex+i]=setHeight}return point}export function getCenteredPositions(itemRects,containerWidth){const rowMap={};itemRects.forEach((itemRect=>{if(rowMap[itemRect.top]){rowMap[itemRect.top].push(itemRect)}else{rowMap[itemRect.top]=[itemRect]}}));let rects=[];const rows=[];const centeredRows=[];Object.keys(rowMap).forEach((key=>{const itemRects=rowMap[key];rows.push(itemRects);const lastItem=itemRects[itemRects.length-1];const end=lastItem.left+lastItem.width;const offset=Math.round((containerWidth-end)/2);let finalRects=itemRects;let canMove=false;if(offset>0){const newRects=[];canMove=itemRects.every((r=>{const newRect=new Rect(r.left+offset,r.top,r.width,r.height,r.id);const noOverlap=!rects.some((r=>Rect.intersects(newRect,r)));newRects.push(newRect);return noOverlap}));if(canMove){finalRects=newRects}}if(!canMove){let intersectingRect;const hasOverlap=itemRects.some((itemRect=>rects.some((r=>{const intersects=Rect.intersects(itemRect,r);if(intersects){intersectingRect=r}return intersects}))));if(hasOverlap){const rowIndex=centeredRows.findIndex((items=>items.includes(intersectingRect)));centeredRows.splice(rowIndex,1,rows[rowIndex])}}rects=rects.concat(finalRects);centeredRows.push(finalRects)}));return centeredRows.flat().sort(((a,b)=>a.id-b.id)).map((itemRect=>new Point(itemRect.left,itemRect.top)))}