/*!
  * Bootstrap base-component.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory(require("./dom/data.js"),require("./dom/event-handler.js")):typeof define==="function"&&define.amd?define(["./dom/data","./dom/event-handler"],factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,global.Base=factory(global.Data,global.EventHandler))})(this,(function(Data,EventHandler){"use strict";const _interopDefaultLegacy=e=>e&&typeof e==="object"&&"default"in e?e:{default:e};const Data__default=_interopDefaultLegacy(Data);const EventHandler__default=_interopDefaultLegacy(EventHandler);const MILLISECONDS_MULTIPLIER=1e3;const TRANSITION_END="transitionend";const getTransitionDurationFromElement=element=>{if(!element){return 0}let{transitionDuration:transitionDuration,transitionDelay:transitionDelay}=window.getComputedStyle(element);const floatTransitionDuration=Number.parseFloat(transitionDuration);const floatTransitionDelay=Number.parseFloat(transitionDelay);if(!floatTransitionDuration&&!floatTransitionDelay){return 0}transitionDuration=transitionDuration.split(",")[0];transitionDelay=transitionDelay.split(",")[0];return(Number.parseFloat(transitionDuration)+Number.parseFloat(transitionDelay))*MILLISECONDS_MULTIPLIER};const triggerTransitionEnd=element=>{element.dispatchEvent(new Event(TRANSITION_END))};const isElement=obj=>{if(!obj||typeof obj!=="object"){return false}if(typeof obj.jquery!=="undefined"){obj=obj[0]}return typeof obj.nodeType!=="undefined"};const getElement=obj=>{if(isElement(obj)){return obj.jquery?obj[0]:obj}if(typeof obj==="string"&&obj.length>0){return document.querySelector(obj)}return null};const execute=callback=>{if(typeof callback==="function"){callback()}};const executeAfterTransition=(callback,transitionElement,waitForTransition=true)=>{if(!waitForTransition){execute(callback);return}const durationPadding=5;const emulatedDuration=getTransitionDurationFromElement(transitionElement)+durationPadding;let called=false;const handler=({target:target})=>{if(target!==transitionElement){return}called=true;transitionElement.removeEventListener(TRANSITION_END,handler);execute(callback)};transitionElement.addEventListener(TRANSITION_END,handler);setTimeout((()=>{if(!called){triggerTransitionEnd(transitionElement)}}),emulatedDuration)};const VERSION="5.1.3";class BaseComponent{constructor(element){element=getElement(element);if(!element){return}this._element=element;Data__default.default.set(this._element,this.constructor.DATA_KEY,this)}dispose(){Data__default.default.remove(this._element,this.constructor.DATA_KEY);EventHandler__default.default.off(this._element,this.constructor.EVENT_KEY);Object.getOwnPropertyNames(this).forEach((propertyName=>{this[propertyName]=null}))}_queueCallback(callback,element,isAnimated=true){executeAfterTransition(callback,element,isAnimated)}static getInstance(element){return Data__default.default.get(getElement(element),this.DATA_KEY)}static getOrCreateInstance(element,config={}){return this.getInstance(element)||new this(element,typeof config==="object"?config:null)}static get VERSION(){return VERSION}static get NAME(){throw new Error('You have to implement the static method "NAME", for each component!')}static get DATA_KEY(){return`bs.${this.NAME}`}static get EVENT_KEY(){return`.${this.DATA_KEY}`}}return BaseComponent}));